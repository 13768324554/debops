#!/bin/bash

# pki-realm: client-side PKI management
# Copyright (C) 2016 Maciej Delmanowski <drybjed@gmail.com>
# Homepage: http://debops.org/

set -eu -o pipefail

umask 022

script="$(basename ${0})"

# Check if an associative array has a specified key present
key_exists() {
    eval '[ ${'$1'[$2]+test_of_existence} ]'
}

# Get an absolute path to a file
get_absolute_path () {
    python -c 'import sys, os.path; print os.path.abspath(sys.argv[1])' "${1}"
}

# Get a relative path to a file
get_relative_path () {
    python -c 'import sys, os.path; print os.path.relpath(sys.argv[1], sys.argv[2])' "${1}" "${2:-$PWD}"
}

initialize_environment () {

    declare -gA config

    config["pki_authority_preference"]="external/acme/internal"

    config["acme_user"]="${PKI_ACME_USER:-pki-acme}"
    config["acme_group"]="${PKI_ACME_GROUP:-pki-acme}"

    config["private_group"]="${PKI_PRIVATE_GROUP:-ssl-cert}"

    config["acme_challenge_dir"]="/srv/www/sites/acme/public/.well-known/acme-challenge"

    config["acme_client"]="acme_tiny"

    local -A acme_client_script_map
    acme_client_script_map=(
        ["acme_tiny"]="/usr/local/lib/pki/acme-tiny"
    )

    config["acme_client_script"]="${acme_client_script_map[${config['acme_client']}]}"

    config["acme_ca"]="le-staging"

    local -A acme_ca_api_map
    acme_ca_api_map=(
        ["le-live"]="https://acme-v01.api.letsencrypt.org"
        ["le-staging"]="https://acme-staging.api.letsencrypt.org"
    )

    config["acme_ca_api"]="${acme_ca_api_map[${config['acme_ca']}]}"

    config["acme_expiration_days"]="30"

    config["acme_expiration_seconds"]="$(( 60 * 60 * 24 * ${config['acme_expiration_days']} ))"

    config["acme_root_ca_path"]="/usr/share/ca-certificates"
    config["acme_root_ca_file"]="mozilla/DST_Root_CA_X3.crt"

    config["acme_intermediate_url"]="https://letsencrypt.org/certs/lets-encrypt-x1-cross-signed.pem"

    config["pki_default_ca_bundle"]="/etc/ssl/certs/ca-certificates.crt"
    config["pki_default_subject"]="CN=$(hostname --fqdn)"
    config["pki_default_fqdn"]="$(hostname --fqdn)"
    config["pki_default_domain"]="$(dnsdomainname)"
    config["pki_default_subdomains"]="_wildcard_"

    config["internal_expiration_days"]="14"
    config["internal_expiration_seconds"]="$(( 60 * 60 * 24 * ${config['internal_expiration_days']} ))"

    config["subject"]=""
    config["domains"]=""
    config["subdomains"]=""

    config["acme_default_subject"]="CN=$(dnsdomainname)"
    config["acme_default_domain"]="$(dnsdomainname)"
    config["acme_default_subdomains"]="www/ftp/mail/smtp/imap"

    config["acme_subject"]=""
    config["acme_domains"]=""
    config["acme_subdomains"]=""

    if [ "$EUID" -eq 0 ] ; then

        config["pki_root"]="${PKI_ROOT:-/etc/pki}"
        config["pki_library"]="${PKI_LIBRARY:-openssl}"
        config["pki_acme"]="${PKI_ACME:-true}"
        config["pki_acme_library"]="${PKI_ACME_LIBRARY:-openssl}"
        config["pki_internal"]="${PKI_INTERNAL:-true}"

        config["pki_realms"]="${config['pki_root']}/realms"
        config["pki_hooks"]="${config['pki_root']}/hooks"

        config["public_dir_group"]="root"
        config["public_file_group"]="root"

        config["realm_dir_group"]="root"
        config["realm_file_group"]="root"

        if $(getent group ${config['private_group']} > /dev/null) ; then
            config["private_dir_group"]="${config['private_group']}"
            config["private_file_group"]="${config['private_group']}"
        else
            config["private_dir_group"]="root"
            config["private_file_group"]="root"
        fi

        if $(getent group ${config['acme_group']} > /dev/null) ; then
            config["acme_dir_group"]="${config['acme_group']}"
            config["acme_file_group"]="${config['acme_group']}"
        else
            config["acme_dir_group"]="root"
            config["acme_file_group"]="root"
        fi

        config["public_dir_mode"]="755"
        config["acme_dir_mode"]="770"
        config["private_dir_mode"]="750"
        config["realm_dir_mode"]="700"

        config["public_file_mode"]="644"
        config["acme_file_mode"]="640"
        config["private_file_mode"]="640"
        config["realm_file_mode"]="400"

    else

        config["pki_root"]="${PKI_ROOT:-${XDG_CONFIG_HOME:-${HOME}/.config}/pki}"
        config["pki_library"]="${PKI_LIBRARY:-openssl}"
        config["pki_acme"]="${PKI_ACME:-true}"
        config["pki_acme_library"]="${PKI_ACME_LIBRARY:-openssl}"
        config["pki_internal"]="${PKI_INTERNAL:-true}"

        config["pki_realms"]="${config['pki_root']}/realms"
        config["pki_hooks"]="${config['pki_root']}/hooks"

        config["public_dir_group"]="$(id -gn)"
        config["public_file_group"]="$(id -gn)"

        config["private_dir_group"]="$(id -gn)"
        config["private_file_group"]="$(id -gn)"

        config["realm_dir_group"]="$(id -gn)"
        config["realm_file_group"]="$(id -gn)"

        config["acme_dir_group"]="$(id -gn)"
        config["acme_file_group"]="$(id -gn)"

        config["public_dir_mode"]="755"
        config["acme_dir_mode"]="770"
        config["private_dir_mode"]="700"
        config["realm_dir_mode"]="700"

        config["public_file_mode"]="644"
        config["acme_file_mode"]="640"
        config["private_file_mode"]="600"
        config["realm_file_mode"]="400"

    fi

    test -d ${config['pki_root']} || mkdir -p -m ${config['public_dir_mode']} ${config['pki_root']}
}

print_usage () {
    cat << EOF
Usage: ${script} <command> [parameters]
EOF

}

check_openssl_key_req_match () {
    local check_key="${1}"
    local check_req="${2}"

    local md5_key="$(openssl rsa -noout -modulus -in ${check_key} | md5sum | awk '{print $1}')"
    local md5_req="$(openssl req -noout -modulus -in ${check_req} | md5sum | awk '{print $1}')"

    if [ "${md5_key}" = "${md5_req}" ] ; then
        return 0
    else
        return 1
    fi
}

check_openssl_key_crt_match () {
    local check_key="${1}"
    local check_crt="${2}"

    if [ -r ${check_key} -a -r ${check_crt} ] ; then
        local md5_key="$(openssl rsa  -noout -modulus -in ${check_key} | md5sum | awk '{print $1}')"
        local md5_crt="$(openssl x509 -noout -modulus -in ${check_crt} | md5sum | awk '{print $1}')"

        if [ "${md5_key}" = "${md5_crt}" ] ; then
            return 0
        else
            return 1
        fi
    else
        return 1
    fi
}

enter_realm () {

    local realm="${1}"
    local config_file="${2:-config/realm.conf}"

    test -d ${config['pki_realms']}/${realm} || mkdir -p -m ${config['public_dir_mode']} ${config['pki_realms']}/${realm}

    cd ${config['pki_realms']}/${realm}
    local rc=$?

    if [ -r ${config_file} ] ; then

        # FIXME: Add a code that checks if the config file has no dangerous code inside
        . ${config_file}
    fi

    return ${rc}
}

run_external_script () {

    if [ -r external/script ] ; then

        export PKI_SCRIPT_REALM="${config['name']}"
        export PKI_SCRIPT_FQDN="${config['pki_default_fqdn']}"
        export PKI_SCRIPT_SUBJECT="${config['subject']:-${config['pki_default_subject']}}"
        export PKI_SCRIPT_DOMAINS="${config['domains']:-${config['pki_default_domain']}}"
        export PKI_SCRIPT_SUBDOMAINS="${config['subdomains']:-${config['pki_default_subdomains']}}"

        test -x external/script || chmod ug+x external/script

        cd external
        ( ./script )
        cd - > /dev/null 2>&1
    fi
}

update_symlink () {

    local symlink_target="${1}"

    if [ -n "${symlink_target}" ] ; then

        shift 1

        for target in ${@} ; do
            if  [ -r ${target} ] ; then
                ln -sf ${target} ${symlink_target}
                break
            fi
        done

    fi
}

create_openssl_config () {

    local config_file="${1:-config/openssl.conf}"
    local config_type="${2:-internal}"
    local req_dn="${3}"
    local req_domains="${4}"
    local req_subdomains="${5}"

    if [ -n "${config_file}" -a -n "${req_dn}" ] ; then

        cat << EOF > ${config_file}
# Configuration file generated by pki-realm

[ req ]
default_md         = sha256
default_bits       = 2048
default_keyfile    = private/key.pem
prompt             = no
encrypt_key        = no
distinguished_name = req_dn
req_extensions     = ext_req
utf8               = yes
string_mask        = utf8only
EOF

        if [ "${config_type}" = "internal" ] ; then
            cat << EOF >> ${config_file}
attributes         = req_attributes

[ req_attributes ]
challengePassword  = \${ENV::PKI_SESSION_TOKEN}
EOF
        fi

        cat << EOF >> ${config_file}

[ req_dn ]
EOF

        echo "${req_dn}" | tr "/" "\n" | sed \
            -e 's/^[Cc]=/countryName=/' \
            -e 's/^[Ss][Tt]=/stateOrProvinceName=/' \
            -e 's/^[Ll]=/localityName=/' \
            -e 's/^[Oo]=/organizationName=/' \
            -e 's/^[Oo][Uu]=/organizationalUnitName=/' \
            -e 's/^[Cc][Nn]=/commonName=/' >> ${config_file}

        cat << EOF >> ${config_file}

[ ext_req ]
basicConstraints   = CA:FALSE
keyUsage           = digitalSignature, keyEncipherment
extendedKeyUsage   = serverAuth, clientAuth
EOF
        if [ -n "${req_domains}" ] ; then
            cat << EOF >> ${config_file}
subjectAltName     = @ext_req_san

[ ext_req_san ]
EOF

            local domains=( $(echo "${req_domains}" | tr "/" " ") )
            local subdomains=( $(echo "${req_subdomains}" | tr "/" " ") )

            for i in "${!domains[@]}" ; do
                printf "%-18s = %s\n" "DNS.${i}" "${domains[${i}]}" >> ${config_file}
            done
            if [ ${#subdomains[@]} -gt 0 ] ; then
                local dnsid="${#domains[@]}"
                for i in "${!domains[@]}" ; do
                    for j in "${!subdomains[@]}" ; do
                        if [ "${subdomains[${j}]}" == "_wildcard_" ] ; then
                            printf "%-18s = %s\n" "DNS.${dnsid}" "*.${domains[${i}]}" >> ${config_file}
                        else
                            printf "%-18s = %s\n" "DNS.${dnsid}" "${subdomains[${j}]}.${domains[${i}]}" >> ${config_file}
                        fi
                        local dnsid="$(( ${dnsid} + 1 ))"
                    done
                done
            fi

        fi

    fi
}

create_gnutls_config () {

    local config_file="${1:-config/gnutls.conf}"
    local config_type="${2:-internal}"
    local req_dn="${3}"
    local req_domains="${4}"
    local req_subdomains="${5}"

    if [ -n "${config_file}" -a -n "${req_dn}" ] ; then

        cat << EOF > ${config_file}
# Configuration file generated by pki-realm

signing_key
encryption_key
tls_www_client
tls_www_server

EOF

        if [ -n "${PKI_SESSION_TOKEN:-}" -a "${config_type}" = "internal" ] ; then
            cat << EOF >> ${config_file}
# This password is meaningless outside of current session
challenge_password  = ${PKI_SESSION_TOKEN:-}

EOF
        fi

        echo "${req_dn}" | tr "/" "\n" | sed \
            -e 's/^[Cc]=/country = "/' \
            -e 's/^[Ss][Tt]=/state = "/' \
            -e 's/^[Ll]=/locality = "/' \
            -e 's/^[Oo]=/organization = "/' \
            -e 's/^[Oo][Uu]=/unit = "/' \
            -e 's/^[Cc][Nn]=/cn = "/' \
            -e 's/$/"/' >> ${config_file}

        if [ -n "${req_domains}" ] ; then

            local domains=( $(echo "${req_domains}" | tr "/" " ") )
            local subdomains=( $(echo "${req_subdomains}" | tr "/" " ") )

            for i in "${!domains[@]}" ; do
                printf 'dns_name = "%s"\n' "${domains[${i}]}" >> ${config_file}
            done
            if [ ${#subdomains[@]} -gt 0 ] ; then
                local dnsid="${#domains[@]}"
                for i in "${!domains[@]}" ; do
                    for j in "${!subdomains[@]}" ; do
                        if [ "${subdomains[${j}]}" == "_wildcard_" ] ; then
                            printf 'dns_name = "%s"\n' "*.${domains[${i}]}" >> ${config_file}
                        else
                            printf 'dns_name = "%s"\n' "${subdomains[${j}]}.${domains[${i}]}" >> ${config_file}
                        fi
                        local dnsid="$(( ${dnsid} + 1 ))"
                    done
                done
            fi

        fi

    fi
}

save_realm_config () {

    local config_file="${1:-config/realm.conf}"

    if [ -r ${config_file} ] ; then
        if $(grep -q -E "^#\s+Configuration\s+file\s+generated\s+by\s+pki-realm$" ${config_file}) ; then
            rm -f ${config_file}
        fi
    fi

    if [ ! -r ${config_file} ] ; then
        cat << EOF > ${config_file}
# Configuration file generated by pki-realm

EOF
        for key in "${!config[@]}" ; do
            echo "config['${key}']='${config[${key}]}'" >> ${config_file}
        done
    fi
}

generate_openssl_request () {

    local req_config="${1}"
    local req_out="${2}"

    if [ -n "${req_config}" -a -n "${req_out}" ] ; then
        if [ -r ${req_config} -a ! -r ${req_out} ] ; then

            local req_keyfile=$(grep -E '^default_keyfile\s+=\s+' ${req_config} | awk '{print $3}')
            if [ -n "${req_keyfile}" ] ; then
                openssl req -new -key ${req_keyfile} -config ${req_config} -out ${req_out}.tmp
            else
                openssl req -new -config ${req_config} -out ${req_out}.tmp
            fi
            test -r ${req_out}.tmp && mv ${req_out}.tmp ${req_out}

        fi
    fi

}

generate_gnutls_request () {

    local req_config="${1}"
    local req_out="${2}"

    if [ -n "${req_config}" -a -n "${req_out}" ] ; then
        if [ -r ${req_config} -a ! -r ${req_out} ] ; then

            certtool --generate-request --template ${req_config} \
                     --load-privkey private/key.pem --outfile ${req_out}.tmp
            # Remove text output from the request
            test -r ${req_out}.tmp && sed -n -i '/-----BEGIN NEW CERTIFICATE REQUEST-----/,$ p' ${req_out}.tmp
            test -r ${req_out}.tmp && mv ${req_out}.tmp ${req_out}

        fi
    fi

}

generate_openssl_rsa_realm_key () {

    local key_file="${1:-private/realm_key.pem}"
    local key_size="${2:-2048}"
    local key_group="${3:-${config['realm_file_group']}}"

    test -r ${key_file} || openssl genrsa -out ${key_file}.tmp ${key_size}

    if [ -r ${key_file}.tmp ] ; then
        chmod ${config['realm_file_mode']} ${key_file}.tmp
        chgrp ${key_group} ${key_file}.tmp
        mv ${key_file}.tmp ${key_file}
    fi

    if [ "$(stat -c %a ${key_file})" != "${config['realm_file_mode']}" ] ; then
        chmod ${config['realm_file_mode']} ${key_file}
    fi
    if [ "$(stat -c %G ${key_file})" != "${key_group}" ] ; then
        chgrp ${key_group} ${key_file}
    fi

}

generate_gnutls_rsa_realm_key () {

    local key_file="${1:-private/realm_key.pem}"
    local key_size="${2:-2048}"
    local key_group="${3:-${config['realm_file_group']}}"

    if ! [ -r ${key_file} ] ; then
        if ! awk -v ver="$(certtool --version | head -n 1 | awk '{print $NF}')" 'BEGIN { if (ver < 3.1.0) exit 1; }'; then
            certtool --generate-privkey --outfile ${key_file}.tmp --bits ${key_size}
        else
            certtool --generate-privkey --rsa --outfile ${key_file}.tmp --bits ${key_size}
        fi
    fi

    if [ -r ${key_file}.tmp ] ; then
        sed -n -i '/-----BEGIN RSA PRIVATE KEY-----/,$ p' ${key_file}.tmp
        chmod ${config['realm_file_mode']} ${key_file}.tmp
        chgrp ${key_group} ${key_file}.tmp
        mv ${key_file}.tmp ${key_file}
    fi

    if [ "$(stat -c %a ${key_file})" != "${config['realm_file_mode']}" ] ; then
        chmod ${config['realm_file_mode']} ${key_file}
    fi
    if [ "$(stat -c %G ${key_file})" != "${key_group}" ] ; then
        chgrp ${key_group} ${key_file}
    fi

}

generate_openssl_rsa_private_key () {

    local key_file="${1:-private/key.pem}"
    local key_size="${2:-2048}"
    local key_group="${3:-${config['private_file_group']}}"

    test -r ${key_file} || openssl genrsa -out ${key_file}.tmp ${key_size}

    if [ -r ${key_file}.tmp ] ; then
        chmod ${config['private_file_mode']} ${key_file}.tmp
        chgrp ${key_group} ${key_file}.tmp
        mv ${key_file}.tmp ${key_file}
    fi

    if [ "$(stat -c %a ${key_file})" != "${config['private_file_mode']}" ] ; then
        chmod ${config['private_file_mode']} ${key_file}
    fi
    if [ "$(stat -c %G ${key_file})" != "${key_group}" ] ; then
        chgrp ${key_group} ${key_file}
    fi

}

generate_gnutls_rsa_private_key () {

    local key_file="${1:-private/key.pem}"
    local key_size="${2:-2048}"
    local key_group="${3:-${config['private_file_group']}}"

    if ! [ -r ${key_file} ] ; then
        if ! awk -v ver="$(certtool --version | head -n 1 | awk '{print $NF}')" 'BEGIN { if (ver < 3.1.0) exit 1; }'; then
            certtool --generate-privkey --outfile ${key_file}.tmp --bits ${key_size}
        else
            certtool --generate-privkey --rsa --outfile ${key_file}.tmp --bits ${key_size}
        fi
    fi

    if [ -r ${key_file}.tmp ] ; then
        sed -n -i '/-----BEGIN RSA PRIVATE KEY-----/,$ p' ${key_file}.tmp
        chmod ${config['private_file_mode']} ${key_file}.tmp
        chgrp ${key_group} ${key_file}.tmp
        mv ${key_file}.tmp ${key_file}
    fi

    if [ "$(stat -c %a ${key_file})" != "${config['private_file_mode']}" ] ; then
        chmod ${config['private_file_mode']} ${key_file}
    fi
    if [ "$(stat -c %G ${key_file})" != "${key_group}" ] ; then
        chgrp ${key_group} ${key_file}
    fi

}

create_public_directories () {

    local dir_group="${1}"
    if [ -n "${dir_group}" ] ; then
        shift
    else
        return 1
    fi

    local directories=( ${@} )

    for directory in ${directories[@]} ; do
        test -d ${directory} || mkdir -p -m ${config['public_dir_mode']} ${directory}
        if [ "$(stat -c %a ${directory})" != "${config['public_dir_mode']}" ] ; then
            chmod ${config['public_dir_mode']} ${directory}
        fi
        if [ "$(stat -c %G ${directory})" != "${dir_group}" ] ; then
            chgrp ${dir_group} ${directory}
        fi
    done

}

create_private_directories () {

    local dir_group="${1}"
    if [ -n "${dir_group}" ] ; then
        shift
    else
        return 1
    fi

    local directories=( ${@} )

    for directory in ${directories[@]} ; do
        test -d ${directory} || mkdir -p -m ${config['private_dir_mode']} ${directory}
        if [ "$(stat -c %a ${directory})" != "${config['private_dir_mode']}" ] ; then
            chmod ${config['private_dir_mode']} ${directory}
        fi
        if [ "$(stat -c %G ${directory})" != "${dir_group}" ] ; then
            chgrp ${dir_group} ${directory}
        fi
    done

}

check_expiration_time () {

    local cert_file="${1}"
    local seconds="${2}"

    if [ -n "${cert_file}" -a -r ${cert_file} ] ; then

        current_time="$(date +%s)"
        cert_enddate="$(openssl x509 -in ${cert_file} -noout -enddate | cut -d= -f2)"
        cert_expires=$(date --date="${cert_enddate}" +%s)

        if [ -n "${seconds}" ] ; then
            cert_expires="$(( ${cert_expires} - ${seconds} ))"
        fi

        if (( (${cert_expires} - ${current_time}) >= 0 )) ; then
            return 0
        else
            return 1
        fi

    else
        return 1
    fi
}

request_acme_tiny_certificate () {

    if [ "${config['pki_acme']}" = "true" -a -x ${config['acme_client_script']} -a -d ${config['acme_challenge_dir']} -a ! -r acme/error.log -a -r acme/request.pem ] ; then

        if ! ( check_expiration_time acme/cert.pem ${config['acme_expiration_seconds']} && check_openssl_key_crt_match private/key.pem acme/cert.pem ) ; then

            if [ "$EUID" -eq 0 ] ; then

                set +e
                su --shell /bin/sh -c "${config['acme_client_script']} --account-key acme/account_key.pem \
                    --ca ${config['acme_ca_api']} --csr acme/request.pem \
                    --acme-dir ${config['acme_challenge_dir']} > acme/cert.pem.tmp 2>acme/error.log" "${config['acme_user']}"
                set -e

            else

                set +e
                ${config['acme_client_script']} --account-key acme/account_key.pem \
                    --ca ${config['acme_ca_api']} --csr acme/request.pem \
                    --acme-dir ${config['acme_challenge_dir']} > acme/cert.pem.tmp 2>acme/error.log
                set -e

            fi

            if [ -r acme/cert.pem.tmp -a -s acme/cert.pem.tmp ] ; then

                test -r acme/cert.pem && mv acme/cert.pem acme/cert.pem.old || true
                mv acme/cert.pem.tmp acme/cert.pem

                if [ ! -r acme/root.pem ] ; then
                    if [ -n "${config['acme_root_ca_path']}" -a -n "${config['acme_root_ca_file']}" ] ; then
                        if [ -r ${config['acme_root_ca_path']}/${config['acme_root_ca_file']} ] && grep -q "${config['acme_root_ca_file']}" /etc/ca-certificates.conf ; then
                            ln -s ${config['acme_root_ca_path']}/${config['acme_root_ca_file']} acme/root.pem
                        fi
                    fi
                fi

                if [ ! -r acme/intermediate.pem ] ; then
                    if [ -n "${config['acme_intermediate_url']}" ] ; then
                        curl -s -o acme/intermediate.pem ${config['acme_intermediate_url']}
                    fi
                fi

                if [ -r acme/error.log ] ; then
                    rm -f acme/error.log
                fi

            elif [ -r acme/cert.pem.tmp -a ! -s acme/cert.pem.tmp ] ; then
                rm -f acme/cert.pem.tmp
            fi

        fi

    fi

}

check_files () {

    local name="${config['name']}"
    local library="${config['pki_library']}"
    local acme_library="${config['pki_acme_library']}"

    if [ "${config['pki_internal']}" == "true" ] ; then

        if [ ! -r private/realm_key.pem ] ; then
            generate_${library}_rsa_realm_key private/realm_key.pem
            if [ ! -r private/key.pem ] ; then
                install -g ${config['private_file_group']} -m ${config['private_file_mode']} /dev/null private/key.pem.tmp
                cat private/realm_key.pem >> private/key.pem.tmp
                mv private/key.pem.tmp private/key.pem
            fi
        fi

        if [ -n "${PKI_SESSION_TOKEN:-}" -a -r internal/cert.pem ] ; then
            if ! ( check_expiration_time internal/cert.pem ${config['internal_expiration_seconds']} && check_openssl_key_crt_match private/key.pem internal/cert.pem ) ; then
                rm -f internal/${library}.conf internal/request.pem
            fi
        fi

        if [ ! -r internal/${library}.conf -a ! -r internal/request.pem ] ; then

            if [[ ${name} != *.* && ${name} != *@* ]] ; then

                create_${library}_config internal/${library}.conf internal "${config['subject']:-${config['pki_default_subject']}}" "${config['domains']:-${config['pki_default_domain']}}" "${config['subdomains']:-${config['pki_default_subdomains']}}"

            elif [[ ${name} == *.* && ${name} != *@* ]] ; then

                create_${library}_config internal/${library}.conf internal "${config['subject']:-cn=${name}}" "${config['domains']:-${name:-${config['pki_default_domain']}}}" "${config['subdomains']:-${config['pki_default_subdomains']}}"

            fi

            generate_${library}_request internal/${library}.conf internal/request.pem
        fi

        if [ -r internal/${library}.conf -a -r internal/request.pem ] ; then
            if ! check_openssl_key_req_match private/key.pem internal/request.pem ; then

                rm -f internal/request.pem
                generate_${library}_request internal/${library}.conf internal/request.pem

            fi
        fi

    fi

    if [ "${config['pki_acme']}" = "true" ] ; then

        if [ -r acme/cert.pem -a -r acme/${acme_library}.conf -a -r acme/request.pem ] ; then
            if ! check_expiration_time acme/cert.pem ${config['acme_expiration_seconds']} ; then
                rm -f acme/${acme_library}.conf acme/request.pem
            fi
        fi

        if [ ! -r acme/${acme_library}.conf -a ! -r acme/request.pem ] ; then

            if [[ ${name} != *.* && ${name} != *@* ]] ; then

                create_${acme_library}_config acme/${acme_library}.conf acme "${config['acme_subject']:-${config['acme_default_subject']}}" "${config['acme_domains']:-${config['acme_default_domain']}}" "${config['acme_subdomains']:-${config['acme_default_subdomains']}}"

            elif [[ ${name} == *.* && ${name} != *@* ]] ; then

                create_${acme_library}_config acme/${acme_library}.conf acme "${config['acme_subject']:-cn=${name}}" "${config['acme_domains']:-${name:-${config['acme_default_domain']}}}" "${config['acme_subdomains']:-${config['acme_default_subdomains']}}"

            fi

            generate_${library}_rsa_private_key acme/account_key.pem 4096 "${config['acme_file_group']}"
            generate_${acme_library}_request acme/${acme_library}.conf acme/request.pem
            chgrp "${config['acme_file_group']}" acme/request.pem
            chmod "${config['acme_file_mode']}" acme/request.pem
            chmod "${config['acme_dir_mode']}" acme
        fi

        if [ -r acme/${acme_library}.conf -a -r acme/request.pem ] ; then
            if ! check_openssl_key_req_match private/key.pem acme/request.pem ; then

                rm -f acme/request.pem
                generate_${acme_library}_request acme/${acme_library}.conf acme/request.pem
                chgrp "${config['acme_file_group']}" acme/request.pem
                chmod "${config['acme_file_mode']}" acme/request.pem

            fi

        elif [ -r acme/${acme_library}.conf -a ! -r acme/request.pem ] ; then

            generate_${acme_library}_request acme/${acme_library}.conf acme/request.pem
            chgrp "${config['acme_file_group']}" acme/request.pem
            chmod "${config['acme_file_mode']}" acme/request.pem

        fi

    fi

}

# Select the preferred authority in a given PKI realm (external, acme,
# internal) and check all of the files, make sure that everything is in order
process_public_files () {

    local authority_preference=( $(echo "${config['pki_authority_preference']}" | tr "/" " ") )

    for authority in ${authority_preference[@]} ; do

        if [ -r ${authority}/cert.pem ] && ( check_expiration_time ${authority}/cert.pem $(( 60 * 60 * 24 * 10 )) || [ "${authority}" = "${authority_preference[-1]}" ] ) ; then

            if ! diff -q -N ${authority}/cert.pem public/cert.pem > /dev/null ; then

                for source_file in ${authority}/cert.pem ${authority}/intermediate.pem ${authority}/root.pem ${authority}/alt_intermediate.pem ${authority}/alt_root.pem ; do

                    if [ -r ${source_file} ] ; then
                        if ! diff -q -N ${source_file} ${source_file/${authority}/public} > /dev/null ; then
                            ln -sf $(get_relative_path "${source_file}" "public") ${source_file/${authority}/public}.tmp
                        fi
                    elif [ ! -r ${source_file} -a -r ${source_file/${authority}/public} ] ; then
                        rm -f ${source_file/${authority}/public}
                    fi

                done

                if [ -r public/cert.pem.tmp -a -r public/intermediate.pem.tmp ] ; then
                        cat public/cert.pem.tmp public/intermediate.pem.tmp > public/cert_intermediate.pem.tmp
                elif [ -r public/cert.pem.tmp -a -r public/intermediate.pem ] ; then
                        cat public/cert.pem.tmp public/intermediate.pem > public/cert_intermediate.pem.tmp
                fi

                if [ -r public/intermediate.pem.tmp -a -r public/root.pem.tmp ] ; then
                    cat public/intermediate.pem.tmp public/root.pem.tmp > public/intermediate_root.pem.tmp
                elif [ -r public/intermediate.pem -a -r public/root.pem.tmp ] ; then
                    cat public/intermediate.pem public/root.pem.tmp > public/intermediate_root.pem.tmp
                fi

                if [ -r public/alt_intermediate.pem.tmp -a -r public/alt_root.pem.tmp ] ; then
                    cat public/alt_intermediate.pem.tmp public/alt_root.pem.tmp > public/alt_intermediate_root.pem.tmp
                elif [ -r public/alt_intermediate.pem -a -r public/alt_root.pem.tmp ] ; then
                    cat public/alt_intermediate.pem public/alt_root.pem.tmp > public/alt_intermediate_root.pem.tmp
                fi

            fi

            if [ -r private/key.pem -a -r public/cert.pem -a -r public/intermediate.pem -a -r public/cert_intermediate.pem ] ; then

                if ! check_openssl_key_crt_match private/key.pem public/cert_intermediate.pem ; then
                    test -r public/cert_intermediate.pem.tmp && rm -f public/cert_intermediate.pem.tmp || true
                    cat public/cert.pem public/intermediate.pem > public/cert_intermediate.pem.tmp
                fi
            fi

            break

        elif [ ! -r ${authority}/cert.pem -a -r ${authority}/root.pem ] ; then

            if ! diff -q -N ${authority}/root.pem public/root.pem > /dev/null ; then

                for source_file in ${authority}/intermediate.pem ${authority}/root.pem ${authority}/alt_intermediate.pem ${authority}/alt_root.pem ; do

                    if [ -r ${source_file} ] ; then
                        if ! diff -q -N ${source_file} ${source_file/${authority}/public} > /dev/null ; then
                            ln -sf $(get_relative_path "${source_file}" "public") ${source_file/${authority}/public}.tmp
                        fi
                    fi

                done

                if [ -r public/intermediate.pem.tmp -a -r public/root.pem.tmp ] ; then
                    cat public/intermediate.pem.tmp public/root.pem.tmp > public/intermediate_root.pem.tmp
                elif [ -r public/intermediate.pem -a -r public/root.pem.tmp ] ; then
                    cat public/intermediate.pem public/root.pem.tmp > public/intermediate_root.pem.tmp
                fi

                if [ -r public/alt_intermediate.pem.tmp -a -r public/alt_root.pem.tmp ] ; then
                    cat public/alt_intermediate.pem.tmp public/alt_root.pem.tmp > public/alt_intermediate_root.pem.tmp
                elif [ -r public/alt_intermediate.pem -a -r public/alt_root.pem.tmp ] ; then
                    cat public/alt_intermediate.pem public/alt_root.pem.tmp > public/alt_intermediate_root.pem.tmp
                fi

            fi

            break

        fi

    done

}

process_private_files () {

    local current_umask="$(umask)"
    umask 027

    local authority_preference=( $(echo "${config['pki_authority_preference']}" | tr "/" " ") )

    for authority in ${authority_preference[@]} ; do

        if [ -r ${authority}/cert.pem ] && ( check_expiration_time ${authority}/cert.pem $(( 60 * 60 * 24 * 10 )) || [ "${authority}" = "${authority_preference[-1]}" ] ) ; then

            if [ ! -r private/key.pem ] ; then

                if check_openssl_key_crt_match private/realm_key.pem ${authority}/cert.pem ; then

                    test -r private/key.pem.tmp && rm -f private/key.pem.tmp || true
                    install -g ${config['private_file_group']} -m ${config['private_file_mode']} /dev/null private/key.pem.tmp
                    cat private/realm_key.pem >> private/key.pem.tmp

                fi
            fi

            if ! diff -q -N ${authority}/cert.pem public/cert.pem > /dev/null ; then

                if [ -r public/cert.pem.tmp -a -r private/realm_key.pem ] ; then

                    if ! check_openssl_key_crt_match private/key.pem public/cert.pem.tmp ; then

                        test -r private/key.pem.tmp && rm -f private/key.pem.tmp || true
                        install -g ${config['private_file_group']} -m ${config['private_file_mode']} /dev/null private/key.pem.tmp
                        cat private/realm_key.pem >> private/key.pem.tmp

                    fi

                fi

                if [ -r public/cert_intermediate.pem.tmp ] ; then

                    test -r private/key_chain.pem.tmp && rm -f private/key_chain.pem.tmp || true
                    install -g ${config['private_file_group']} -m ${config['private_file_mode']} /dev/null private/key_chain.pem.tmp
                    if [ -r private/key.pem ] && check_openssl_key_crt_match private/key.pem public/cert_intermediate.pem.tmp ; then
                        cat private/key.pem public/cert_intermediate.pem.tmp >> private/key_chain.pem.tmp
                    elif [ -r private/realm_key.pem ] && check_openssl_key_crt_match private/realm_key.pem public/cert_intermediate.pem.tmp ; then
                        cat private/realm_key.pem public/cert_intermediate.pem.tmp >> private/key_chain.pem.tmp
                    fi

                elif [ -r public/cert.pem.tmp ] ; then

                    test -r private/key_chain.pem.tmp && rm -f private/key_chain.pem.tmp || true
                    install -g ${config['private_file_group']} -m ${config['private_file_mode']} /dev/null private/key_chain.pem.tmp
                    if [ -r private/key.pem ] ; then
                        cat private/key.pem public/cert.pem.tmp >> private/key_chain.pem.tmp
                    elif [ -r private/realm_key.pem ] ; then
                        cat private/realm_key.pem public/cert.pem.tmp >> private/key_chain.pem.tmp
                    fi

                fi
            fi

            if [ -r private/key.pem -a -r public/cert_intermediate.pem ] ; then

                if ! check_openssl_key_crt_match private/key.pem public/cert_intermediate.pem ; then
                    test -r private/key_chain.pem.tmp && rm -f private/key_chain.pem.tmp || true
                    install -g ${config['private_file_group']} -m ${config['private_file_mode']} /dev/null private/key_chain.pem.tmp
                    cat private/key.pem public/cert_intermediate.pem >> private/key_chain.pem.tmp
                fi

            elif [ -r private/key.pem -a -r public/cert.pem ] ; then

                if ! check_openssl_key_crt_match private/key.pem public/cert.pem ; then
                    test -r private/key_chain.pem.tmp && rm -f private/key_chain.pem.tmp || true
                    install -g ${config['private_file_group']} -m ${config['private_file_mode']} /dev/null private/key_chain.pem.tmp
                    cat private/key.pem public/cert.pem >> private/key_chain.pem.tmp
                fi

            fi

            break
        fi

    done

    umask ${current_umask}
}

activate_new_files () {

    if [ -r public/cert.pem.tmp -o -r public/root.pem.tmp ] ; then

        if [ ! -r public/intermediate.pem.tmp -a -r public/intermediate.pem ] ; then
            rm -f public/intermediate.pem public/cert_intermediate.pem public/chain.pem
        fi

        if [ ! -r public/alt_intermediate.pem.tmp -a -r public/alt_intermediate.pem ] ; then
            rm -f public/alt_intermediate.pem public/alt_intermediate_root.pem public/alt_trusted.pem
        fi

    fi

    for new_file in $(find public/ -maxdepth 1 -name '*.tmp') ; do
        mv --force ${new_file} ${new_file/.tmp/}
    done

    for new_file in $(find private/ -maxdepth 1 -name '*.tmp') ; do
        mv --force ${new_file} ${new_file/.tmp/}
    done

    update_realm_symlinks

}

update_realm_symlinks () {

    if [ -r public/cert_intermediate.pem ] ; then
        cd public
        update_symlink chain.pem cert_intermediate.pem cert.pem
        update_symlink trusted.pem intermediate_root.pem root.pem
        cd - > /dev/null
    fi

    if [ -r public/alt_intermediate_root.pem ] ; then
        cd public
        update_symlink alt_trusted.pem alt_intermediate_root.pem alt_root.pem
        cd - > /dev/null
    fi

    update_symlink default.crt public/chain.pem public/cert.pem
    update_symlink default.key private/key.pem
    update_symlink default.pem private/key_chain.pem
    update_symlink CA.crt public/alt_trusted.pem public/alt_root.pem public/trusted.pem public/root.pem ${config['pki_default_ca_bundle']}

}

sub_new-realm () {

    local -A args

    local optspec=":hn-:"
    while getopts "${optspec}" optchar; do
        case "${optchar}" in
            -)
                case "${OPTARG}" in
                    name)
                        args["name"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    name=*)
                        args["name"]=${OPTARG#*=}
                        ;;
                    library)
                        args["pki_library"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    library=*)
                        args["pki_library"]=${OPTARG#*=}
                        ;;
                    acme-library)
                        args["pki_acme_library"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-library=*)
                        args["pki_acme_library"]=${OPTARG#*=}
                        ;;
                    internal)
                        args["pki_internal"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    internal=*)
                        args["pki_internal"]=${OPTARG#*=}
                        ;;
                    subject)
                        args["subject"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    subject=*)
                        args["subject"]=${OPTARG#*=}
                        ;;
                    domains)
                        args["domains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    domains=*)
                        args["domains"]=${OPTARG#*=}
                        ;;
                    subdomains)
                        args["subdomains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    subdomains=*)
                        args["subdomains"]=${OPTARG#*=}
                        ;;
                    acme)
                        args["pki_acme"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme=*)
                        args["pki_acme"]=${OPTARG#*=}
                        ;;
                    acme-subject)
                        args["acme_subject"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-subject=*)
                        args["acme_subject"]=${OPTARG#*=}
                        ;;
                    acme-domains)
                        args["acme_domains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-domains=*)
                        args["acme_domains"]=${OPTARG#*=}
                        ;;
                    acme-subdomains)
                        args["acme_subdomains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-subdomains=*)
                        args["acme_subdomains"]=${OPTARG#*=}
                        ;;
                    *)
                        if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
                            echo "Unknown option --${OPTARG}" >&2
                        fi
                        ;;
                esac
                ;;
            h)
                echo "usage: ${script} new-realm <-n|--name[=]realm>" >&2
                exit 2
                ;;
            n)
                args["name"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                ;;
            *)
                if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" = ":" ]; then
                    echo "Non-option argument: '-${OPTARG}'" >&2
                fi
                ;;
        esac
    done

    if key_exists args "name" ; then

        enter_realm ${args['name']}

        local config_changed="false"

        for key in "${!args[@]}" ; do
            if [ -n "${args[${key}]}" ] ; then
                if key_exists config "${key}" ; then
                    if [ "${config[${key}]}" != "${args[${key}]}" ] ; then
                        local config_changed="true"
                        config["${key}"]="${args[${key}]}"
                    fi
                else
                    local config_changed="true"
                    config["${key}"]="${args[${key}]}"
                fi
            fi
        done

        create_public_directories ${config['public_dir_group']} config external internal public
        create_private_directories ${config['private_dir_group']} private
        create_private_directories ${config['acme_dir_group']} acme

        if [ "${config_changed}" = "true" ] ; then
            save_realm_config config/realm.conf
        fi

        local name="${config['name']}"
        local library="${config['pki_library']}"
        local acme_library="${config['pki_acme_library']}"

        if [ "${config['pki_internal']}" = "true" ] ; then
            generate_${library}_rsa_realm_key private/realm_key.pem
            if [ ! -r private/key.pem ] ; then
                install -g ${config['private_file_group']} -m ${config['private_file_mode']} /dev/null private/key.pem.tmp
                cat private/realm_key.pem >> private/key.pem.tmp
                mv private/key.pem.tmp private/key.pem
            fi
        fi

        if [[ ${name} != *.* && ${name} != *@* ]] ; then

            create_${library}_config internal/${library}.conf internal "${config['subject']:-${config['pki_default_subject']}}" "${config['domains']:-${config['pki_default_domain']}}" "${config['subdomains']:-${config['pki_default_subdomains']}}"

            if [ "${config['pki_acme']}" = "true" ] ; then
                create_${acme_library}_config acme/${acme_library}.conf acme "${config['acme_subject']:-${config['acme_default_subject']}}" "${config['acme_domains']:-${config['acme_default_domain']}}" "${config['acme_subdomains']:-${config['acme_default_subdomains']}}"
            fi

        elif [[ ${name} == *.* && ${name} != *@* ]] ; then

            create_${library}_config internal/${library}.conf internal "${config['subject']:-cn=${name}}" "${config['domains']:-${name:-${config['pki_default_domain']}}}" "${config['subdomains']:-${config['pki_default_subdomains']}}"

            if [ "${config['pki_acme']}" = "true" ] ; then
                create_${acme_library}_config acme/${acme_library}.conf acme "${config['acme_subject']:-cn=${name}}" "${config['acme_domains']:-${name:-${config['acme_default_domain']}}}" "${config['acme_subdomains']:-${config['acme_default_subdomains']}}"
            fi

        fi

        generate_${library}_request internal/${library}.conf internal/request.pem
        if [ "${config['pki_acme']}" = "true" ] ; then
            generate_${library}_rsa_private_key acme/account_key.pem 4096 "${config['acme_file_group']}"
            generate_${acme_library}_request acme/${acme_library}.conf acme/request.pem
            chgrp "${config['acme_file_group']}" acme/request.pem
            chmod "${config['acme_file_mode']}" acme/request.pem
            chmod "${config['acme_dir_mode']}" acme
        fi

        update_realm_symlinks

    fi
}

sub_init () {

    local -A args

    local optspec=":hn-:"
    while getopts "${optspec}" optchar; do
        case "${optchar}" in
            -)
                case "${OPTARG}" in
                    name)
                        args["name"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    name=*)
                        args["name"]=${OPTARG#*=}
                        ;;
                    public-dir-group)
                        args["public_dir_group"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    public-dir-group=*)
                        args["public_dir_group"]=${OPTARG#*=}
                        ;;
                    private-dir-group)
                        args["private_dir_group"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    private-dir-group=*)
                        args["private_dir_group"]=${OPTARG#*=}
                        ;;
                    private-file-group)
                        args["private_file_group"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    private-file-group=*)
                        args["private_file_group"]=${OPTARG#*=}
                        ;;
                    library)
                        args["pki_library"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    library=*)
                        args["pki_library"]=${OPTARG#*=}
                        ;;
                    internal)
                        args["pki_internal"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    internal=*)
                        args["pki_internal"]=${OPTARG#*=}
                        ;;
                    subject)
                        args["subject"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    subject=*)
                        args["subject"]=${OPTARG#*=}
                        ;;
                    domains)
                        args["domains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    domains=*)
                        args["domains"]=${OPTARG#*=}
                        ;;
                    subdomains)
                        args["subdomains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    subdomains=*)
                        args["subdomains"]=${OPTARG#*=}
                        ;;
                    default-domain)
                        args["pki_default_domain"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    default-domain=*)
                        args["pki_default_domain"]=${OPTARG#*=}
                        ;;
                    default-subdomains)
                        args["pki_default_subdomains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    default-subdomains=*)
                        args["pki_default_subdomains"]=${OPTARG#*=}
                        ;;
                    acme)
                        args["pki_acme"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme=*)
                        args["acme"]=${OPTARG#*=}
                        ;;
                    acme-subject)
                        args["acme_subject"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-subject=*)
                        args["acme_subject"]=${OPTARG#*=}
                        ;;
                    acme-domains)
                        args["acme_domains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-domains=*)
                        args["acme_domains"]=${OPTARG#*=}
                        ;;
                    acme-subdomains)
                        args["acme_subdomains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-subdomains=*)
                        args["acme_subdomains"]=${OPTARG#*=}
                        ;;
                    acme-ca)
                        args["acme_ca"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-ca=*)
                        args["acme_ca"]=${OPTARG#*=}
                        ;;
                    acme-ca-api)
                        args["acme_ca_api"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-ca-api=*)
                        args["acme_ca_api"]=${OPTARG#*=}
                        ;;
                    acme-default-subdomains)
                        args["acme_default_subdomains"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-default-subdomains=*)
                        args["acme_default_subdomains"]=${OPTARG#*=}
                        ;;
                    acme-challenge-dir)
                        args["acme_challenge_dir"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    acme-challenge-dir=*)
                        args["acme_challenge_dir"]=${OPTARG#*=}
                        ;;
                    *)
                        if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
                            echo "Unknown option --${OPTARG}" >&2
                        fi
                        ;;
                esac
                ;;
            h)
                echo "usage: ${script} init <-n|--name[=]realm>" >&2
                exit 2
                ;;
            n)
                args["name"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                ;;
            *)
                if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" = ":" ]; then
                    echo "Non-option argument: '-${OPTARG}'" >&2
                fi
                ;;
        esac
    done

    if key_exists args "name" ; then

        enter_realm ${args['name']}

        local config_changed="false"

        for key in "${!args[@]}" ; do
            if [ -n "${args[${key}]}" ] ; then
                if key_exists config "${key}" ; then
                    if [ "${config[${key}]}" != "${args[${key}]}" ] ; then
                        local config_changed="true"
                        config["${key}"]="${args[${key}]}"
                    fi
                else
                    local config_changed="true"
                    config["${key}"]="${args[${key}]}"
                fi
            fi
        done

        create_public_directories ${config['public_dir_group']} config external internal public
        create_private_directories ${config['private_dir_group']} private
        create_private_directories ${config['acme_dir_group']} acme

        if [ "${config_changed}" = "true" ] ; then
            save_realm_config config/realm.conf
        fi

    fi
}

sub_run () {

    local -A args

    local optspec=":hn-:"
    while getopts "${optspec}" optchar; do
        case "${optchar}" in
            -)
                case "${OPTARG}" in
                    name)
                        args["name"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                        ;;
                    name=*)
                        args["name"]=${OPTARG#*=}
                        ;;
                    *)
                        if [ "$OPTERR" = 1 ] && [ "${optspec:0:1}" != ":" ]; then
                            echo "Unknown option --${OPTARG}" >&2
                        fi
                        ;;
                esac
                ;;
            h)
                echo "usage: ${script} init <-n|--name[=]realm>" >&2
                exit 2
                ;;
            n)
                args["name"]="${!OPTIND}"; OPTIND=$(( $OPTIND + 1 ))
                ;;
            *)
                if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" = ":" ]; then
                    echo "Non-option argument: '-${OPTARG}'" >&2
                fi
                ;;
        esac
    done

    if key_exists args "name" ; then

        enter_realm ${args['name']}

        check_files
        request_acme_tiny_certificate
        run_external_script
        process_public_files
        process_private_files
        activate_new_files
        update_realm_symlinks

    fi
}

subcommand=""

initialize_environment

if [ $# -gt 0 ] ; then

    subcommand="${1}"

    if [ -n "${subcommand}" ] ; then
        case "${subcommand}" in
            init|new-realm|run)
                shift
                sub_${subcommand} "${@}"
                ;;

            *)
                echo "${script}: Error: unknown subcommand '${subcommand}'" >&2
                print_usage
                exit 1
                ;;
        esac
    fi

else
    print_usage
    exit 1
fi

