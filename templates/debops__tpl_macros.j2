{# vim: foldmarker=[[[,]]]:foldmethod=marker
# Commonly used set of macros in DebOps.
# It can be included in repositories as needed.
# Changes to this file should go upstream: https://github.com/debops/debops-playbooks/blob/master/templates/debops__tpl_macros.j2
#
# Copyright [[[
# =============
#
# Copyright (C) 2014-2017 Maciej Delmanowski <drybjed@drybjed.net>
# Copyright (C) 2015-2017 Robin Schneider <ypid@riseup.net>
# Copyright (C) 2014-2017 DebOps https://debops.org/
#
# This file is part of DebOps.
#
# DebOps is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3, as
# published by the Free Software Foundation.
#
# DebOps is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with DebOps. If not, see https://www.gnu.org/licenses/.
#
# ]]]
#
# Usage [[[
# =========
#
# Copy the template file into your ./templates/ path of a role where it fits
# best. You can/might need to use symlinks to make the macros available from
# different paths in your ./templates/ hierarchy.
#
# Make sure to retain the filename of this file so that automatic updates of
# this file can be implemented.
#
# To use the macros in your own template, this file needs to be included like so:
#
# {% import 'debops__tpl_macros.j2' as debops__tpl_macros with context %}
#
# Then you can start using the macros like this:
#
# {{ debops__tpl_macros.indent(some_content, 4) }}
#
# ]]] #}

{% macro get_yaml_list_for_elem(list_or_elem) %}{# [[[ #}
{#
## Output a YAML formatted list when given a string, boolean or list as argument.
##
## Arguments:
##   list_or_elem: Sting, boolean or list
##
## Return: YAML-formatted list
#}
{{ ([ list_or_elem ]
    if (list_or_elem is string or list_or_elem in [True, False])
    else (list_or_elem|list)) | to_nice_yaml }}
{% endmacro %}{# ]]] #}

{% macro get_realm_yaml_list(domains, fallback_realm) %}{# [[[ #}
{% set custom_realm_list = [] %}
{% if domains and (ansible_local|d() and ansible_local.pki|d() and ansible_local.pki.known_realms|d()) %}
{%   for domain in (get_yaml_list_for_elem(domains) | from_yaml) %}
{%     if domain in ansible_local.pki.known_realms %}
{%       set _ = custom_realm_list.append(domain) %}
{%     elif (domain.split('.')[1:] | join('.')) in ansible_local.pki.known_realms %}
{%       set _ = custom_realm_list.append(domain.split('.')[1:] | join('.')) %}
{%     endif %}
{%   endfor %}
{% endif %}
{% if custom_realm_list|length == 0 %}
{%   set _ = custom_realm_list.append(fallback_realm) %}
{% endif %}
{{ custom_realm_list | to_nice_yaml }}
{% endmacro %}{# ]]] #}

{% macro get_apache_version() %}{# [[[ #}
{{ ansible_local.apache.version
   if (ansible_local|d() and ansible_local.apache|d() and
       ansible_local.apache.version|d())
   else "2.4.0" -}}
{% endmacro %}{# ]]] #}

{% macro get_apache_min_version() %}{# [[[ #}
{{ ansible_local.apache.min_version
   if (ansible_local|d() and ansible_local.apache|d() and
       ansible_local.apache.min_version|d())
   else "2.4.0" -}}
{% endmacro %}{# ]]] #}

{% macro get_openssl_version() %}{# [[[ #}
{{ ansible_local.pki.openssl_version
   if (ansible_local|d() and ansible_local.pki|d() and
       ansible_local.pki.openssl_version|d())
   else "0.0.0" }}
{% endmacro %}{# ]]] #}

{% macro get_gnutls_version() %}{# [[[ #}
{{ ansible_local.pki.gnutls_version
   if (ansible_local|d() and ansible_local.pki|d() and
       ansible_local.pki.gnutls_version|d())
   else "0.0.0" }}
{% endmacro %}{# ]]] #}

{% macro indent(content, width=4, indentfirst=False) %}{# [[[ #}
{#
## Fixed version of the `indent` filter which does not insert trailing spaces on empty lines.
## Note that you can not use this macro like a filter but have to use it like a regular macro.
## Example: {{ debops__tpl_macros.indent(some_content, 4) }}
##
## Python re.sub seems to default to re.MULTILINE in Ansible.
#}
{{ content | indent(width, indentfirst) | regex_replace("[ \\t\\r\\f\\v]+(\\n|$)", "\\1") -}}
{% endmacro %}{# ]]] #}

{%  macro merge_dict(current_dict, to_merge_dict, dict_key='name') %}{# [[[ #}
{#
## Recursively merges nested dictionaries or a nested dictionary with a list of
## dictionaries. In the second case, a key name can be given whose value will
## be used as top-level key for the dictionary item. Note that for merging simple
## dictionaries you should use the regular `combined` Jinja filter.
##
## This can be used to define default variables as YAML dictionaries and then
## use YAML lists of dictionaries either in the inventory or in role dependent
## variables which lets you add multiple YAML lists together.
##
## Arguments:
##   current_dict:   Nested dictionary whose values might get overwritten if
##                   defined in `to_merge_dict`.
##   to_merge_dict:  Dictionary or list of dictionaries being merged into `current_dict`.
##   dict_key:       Key in the `to_merge_dict` item which is used to match the
##                   dictionary item being merged in `current_dict` in case `to_merge_dict`
##                   is a list of dictionaries.
##
## Return: JSON-formatted dictionary
##
## Examples:
##
## 1. Merge single-nested dictionaries:
##     {{ debops__tmpl_macros.merge_dict({'item1': {'key1': 'val1', 'key2': 'val2'},
##                                        'item2': {'key3': 'val3', 'key4': 'val4'}},
##                                       {'item1': {'key2': 'new_val2'},
##                                        'item2': {'key5': 'val5'    }}) }}
##
##     Will output: {"item1": {"key1": "val1", "key2": "new_val2"},
##                   "item2": {"key3": "val3", "key4": "val4", "key5": "val5"}}
##
## 2. Merge double-nested dictionaries:
##     {{ debops__tmpl_macros.merge_dict({'item1': {'prop1': {'key1': 'val1'}}},
##                                       {'item1': {'prop1': {'key3': 'val3'},
##                                                  'prop2': {'key2': 'val2'}}}) }}
##
##     Will output: {"item1": {"prop1": {"key1": "val1", "key3": "val3"},
##                             "prop2": {"key2": "val2"}}}
##
## 3. Merge nested dictionary with list of dictionaries:
##     {{ debops__tmpl_macros.merge_dict({'item1': {'key1': 'val1', 'key2': 'val2'}},
##                                       [{'name': 'item2', 'key3': 'val3'},
##                                        {'name': 'item3', 'key4': 'val4'}]) }}
##
##     Will output: {"item1: {"key1": "val1", "key2": "val2"},
##                   "item2: {"name": "item2", "key3": "val3"},
##                   "item3: {"name": "item3", "key4": "val4"}}
#}
{%   set merged_dict = current_dict %}
{%   if to_merge_dict %}
{%     if to_merge_dict is mapping %}
{%       for dict_name in to_merge_dict.keys() | sort %}
{%         if to_merge_dict[dict_name][dict_key]|d() %}
{%           set _ = merged_dict.update({to_merge_dict[dict_name][dict_key]:(current_dict[to_merge_dict[dict_name][dict_key]]|d({}) | combine(to_merge_dict[dict_name], recursive=True))}) %}
{%         elif to_merge_dict[dict_name][dict_key] is undefined %}
{%           set _ = merged_dict.update({dict_name:(current_dict[dict_name]|d({}) | combine(to_merge_dict[dict_name], recursive=True))}) %}
{%         endif %}
{%       endfor %}
{%     elif to_merge_dict is not string and to_merge_dict is not mapping %}
{%       set flattened_dict = lookup("flattened", to_merge_dict) %}
{%       for element in ([ flattened_dict ] if flattened_dict is mapping else flattened_dict) %}
{%         if element[dict_key]|d() %}
{%           set _ = merged_dict.update({element[dict_key]:(current_dict[element[dict_key]]|d({}) | combine(element, recursive=True))}) %}
{%         endif %}
{%       endfor %}
{%     endif %}
{%   endif %}
{{ merged_dict | to_json }}
{% endmacro %}{# ]]] #}
